import { LEFT_ARROW, RIGHT_ARROW, UP_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';
import { NgTemplateOutlet } from '@angular/common';
import * as i0 from '@angular/core';
import { inject, signal, Injectable, ElementRef, DestroyRef, viewChild, TemplateRef, input, booleanAttribute, computed, ViewEncapsulation, ChangeDetectionStrategy, Component, ChangeDetectorRef, Injector, EventEmitter, viewChildren, contentChildren, afterNextRender, effect, forwardRef, Output, Input, NgModule } from '@angular/core';
import { toSignal, takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';
import { ReplaySubject, Subject, of } from 'rxjs';
import { tap, switchMap, filter, take, map, bufferCount } from 'rxjs/operators';
import * as i1 from 'ng-zorro-antd/icon';
import { NzIconModule } from 'ng-zorro-antd/icon';
import { _IdGenerator } from '@angular/cdk/a11y';
import { __esDecorate, __runInitializers } from 'tslib';
import { Directionality } from '@angular/cdk/bidi';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { thumbMotion } from 'ng-zorro-antd/core/animation';
import { WithConfig, NzConfigService } from 'ng-zorro-antd/core/config';
import { NzOutletModule } from 'ng-zorro-antd/core/outlet';

class NzSegmentedService {
    defaultName = inject(_IdGenerator).getId('segmented_');
    name = signal(this.defaultName, ...(ngDevMode ? [{ debugName: "name" }] : []));
    selected$ = new ReplaySubject(1);
    activated$ = new ReplaySubject(1);
    change$ = new Subject();
    disabled$ = new ReplaySubject(1);
    animationDone$ = new Subject();
    keydown$ = new Subject();
    setName(name) {
        this.name.set(typeof name === 'undefined' ? this.defaultName : name);
    }
    ngOnDestroy() {
        this.selected$.complete();
        this.activated$.complete();
        this.change$.complete();
        this.disabled$.complete();
        this.animationDone$.complete();
        this.keydown$.complete();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedService, decorators: [{
            type: Injectable
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzSegmentedItemComponent {
    animationType = inject(ANIMATION_MODULE_TYPE, { optional: true });
    service = inject(NzSegmentedService);
    elementRef = inject(ElementRef);
    destroyRef = inject(DestroyRef);
    templateRef = viewChild.required('content', { read: TemplateRef });
    nzValue = input.required(...(ngDevMode ? [{ debugName: "nzValue" }] : []));
    nzIcon = input(...(ngDevMode ? [undefined, { debugName: "nzIcon" }] : []));
    nzDisabled = input(false, ...(ngDevMode ? [{ debugName: "nzDisabled", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hasLabel = computed(() => this.templateRef()
        .createEmbeddedView({})
        .rootNodes.some(node => node.textContent.trim().length > 0), ...(ngDevMode ? [{ debugName: "hasLabel" }] : []));
    name = this.service.name.asReadonly();
    isChecked = signal(false, ...(ngDevMode ? [{ debugName: "isChecked" }] : []));
    parentDisabled = toSignal(this.service.disabled$, { initialValue: false });
    finalDisabled = computed(() => this.nzDisabled() || this.parentDisabled(), ...(ngDevMode ? [{ debugName: "finalDisabled" }] : []));
    ngOnInit() {
        this.service.selected$
            .pipe(tap(value => {
            this.isChecked.set(false);
            if (value === this.nzValue()) {
                this.service.activated$.next(this.elementRef.nativeElement);
            }
        }), switchMap(value => {
            if (this.animationType === 'NoopAnimations') {
                return of(value);
            }
            return this.service.animationDone$.pipe(filter(event => event.toState === 'to' || event.toState === 'toVertical'), take(1), map(() => value));
        }), filter(value => value === this.nzValue()), takeUntilDestroyed(this.destroyRef))
            .subscribe(() => this.isChecked.set(true));
    }
    handleClick() {
        if (!this.nzDisabled() && !this.parentDisabled()) {
            this.service.selected$.next(this.nzValue());
            this.service.change$.next(this.nzValue());
        }
    }
    handleKeydown(event) {
        if (this.finalDisabled()) {
            return;
        }
        if (event.keyCode === LEFT_ARROW ||
            event.keyCode === RIGHT_ARROW ||
            event.keyCode === UP_ARROW ||
            event.keyCode === DOWN_ARROW) {
            this.service.keydown$.next(event);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.0", type: NzSegmentedItemComponent, isStandalone: true, selector: "label[nz-segmented-item],label[nzSegmentedItem]", inputs: { nzValue: { classPropertyName: "nzValue", publicName: "nzValue", isSignal: true, isRequired: true, transformFunction: null }, nzIcon: { classPropertyName: "nzIcon", publicName: "nzIcon", isSignal: true, isRequired: false, transformFunction: null }, nzDisabled: { classPropertyName: "nzDisabled", publicName: "nzDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "handleClick()", "keydown": "handleKeydown($event)" }, properties: { "class.ant-segmented-item-selected": "isChecked()", "class.ant-segmented-item-disabled": "finalDisabled()" }, classAttribute: "ant-segmented-item" }, viewQueries: [{ propertyName: "templateRef", first: true, predicate: ["content"], descendants: true, read: TemplateRef, isSignal: true }], exportAs: ["nzSegmentedItem"], ngImport: i0, template: `
    <input
      class="ant-segmented-item-input"
      type="radio"
      [disabled]="finalDisabled()"
      [checked]="isChecked()"
      [attr.name]="name()"
      (click)="$event.stopPropagation()"
    />
    <div class="ant-segmented-item-label" [attr.aria-selected]="isChecked()">
      @if (nzIcon(); as icon) {
        <span class="ant-segmented-item-icon">
          <nz-icon [nzType]="icon" />
        </span>
        @if (hasLabel()) {
          <span>
            <ng-template [ngTemplateOutlet]="content" />
          </span>
        }
      } @else {
        <ng-template [ngTemplateOutlet]="content" />
      }
    </div>

    <ng-template #content>
      <ng-content></ng-content>
    </ng-template>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: NzIconModule }, { kind: "directive", type: i1.NzIconDirective, selector: "nz-icon,[nz-icon]", inputs: ["nzSpin", "nzRotate", "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], exportAs: ["nzIcon"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'label[nz-segmented-item],label[nzSegmentedItem]',
                    exportAs: 'nzSegmentedItem',
                    imports: [NzIconModule, NgTemplateOutlet],
                    template: `
    <input
      class="ant-segmented-item-input"
      type="radio"
      [disabled]="finalDisabled()"
      [checked]="isChecked()"
      [attr.name]="name()"
      (click)="$event.stopPropagation()"
    />
    <div class="ant-segmented-item-label" [attr.aria-selected]="isChecked()">
      @if (nzIcon(); as icon) {
        <span class="ant-segmented-item-icon">
          <nz-icon [nzType]="icon" />
        </span>
        @if (hasLabel()) {
          <span>
            <ng-template [ngTemplateOutlet]="content" />
          </span>
        }
      } @else {
        <ng-template [ngTemplateOutlet]="content" />
      }
    </div>

    <ng-template #content>
      <ng-content></ng-content>
    </ng-template>
  `,
                    host: {
                        class: 'ant-segmented-item',
                        '[class.ant-segmented-item-selected]': 'isChecked()',
                        '[class.ant-segmented-item-disabled]': 'finalDisabled()',
                        '(click)': 'handleClick()',
                        '(keydown)': 'handleKeydown($event)'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
function normalizeOptions(unnormalized) {
    return unnormalized.map(item => {
        if (typeof item === 'string' || typeof item === 'number') {
            return {
                label: `${item}`,
                value: item
            };
        }
        return item;
    });
}

const NZ_CONFIG_MODULE_NAME = 'segmented';
let NzSegmentedComponent = (() => {
    let _nzSize_decorators;
    let _nzSize_initializers = [];
    let _nzSize_extraInitializers = [];
    return class NzSegmentedComponent {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _nzSize_decorators = [WithConfig()];
            __esDecorate(null, null, _nzSize_decorators, { kind: "field", name: "nzSize", static: false, private: false, access: { has: obj => "nzSize" in obj, get: obj => obj.nzSize, set: (obj, value) => { obj.nzSize = value; } }, metadata: _metadata }, _nzSize_initializers, _nzSize_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        _nzModuleName = NZ_CONFIG_MODULE_NAME;
        nzConfigService = inject(NzConfigService);
        cdr = inject(ChangeDetectorRef);
        service = inject(NzSegmentedService);
        injector = inject(Injector);
        dir = inject(Directionality).valueSignal;
        nzBlock = false;
        nzDisabled = false;
        nzOptions = [];
        nzVertical = false;
        nzShape = 'default';
        nzSize = __runInitializers(this, _nzSize_initializers, 'default');
        /**
         * @description set the `name` attribute of the segmented item native `input[type="radio"]`
         * @since 20.3.0
         */
        nzName = __runInitializers(this, _nzSize_extraInitializers);
        nzValueChange = new EventEmitter();
        viewItemCmps = viewChildren(NzSegmentedItemComponent, ...(ngDevMode ? [{ debugName: "viewItemCmps" }] : []));
        contentItemCmps = contentChildren(NzSegmentedItemComponent, ...(ngDevMode ? [{ debugName: "contentItemCmps" }] : []));
        renderedItemCmps = computed(() => this.viewItemCmps().concat(this.contentItemCmps()), ...(ngDevMode ? [{ debugName: "renderedItemCmps" }] : []));
        isDisabledFirstChange = true;
        value;
        animationState = {
            value: 'to',
            params: thumbAnimationParamsOf()
        };
        normalizedOptions = [];
        onChange = () => { };
        onTouched = () => { };
        constructor() {
            this.service.selected$.pipe(takeUntilDestroyed()).subscribe(value => {
                this.value = value;
            });
            this.service.change$.pipe(takeUntilDestroyed()).subscribe(value => {
                this.nzValueChange.emit(value);
                this.onChange(value);
            });
            this.service.activated$.pipe(bufferCount(2, 1), takeUntilDestroyed()).subscribe(elements => {
                if (this.nzVertical) {
                    this.animationState = {
                        value: 'fromVertical',
                        params: thumbAnimationParamsOf(elements[0], true)
                    };
                    this.cdr.detectChanges();
                    this.animationState = {
                        value: 'toVertical',
                        params: thumbAnimationParamsOf(elements[1], true)
                    };
                    this.cdr.detectChanges();
                }
                else {
                    this.animationState = {
                        value: 'from',
                        params: thumbAnimationParamsOf(elements[0])
                    };
                    this.cdr.detectChanges();
                    this.animationState = {
                        value: 'to',
                        params: thumbAnimationParamsOf(elements[1])
                    };
                    this.cdr.detectChanges();
                }
            });
            this.service.keydown$
                .pipe(filter(() => !this.nzDisabled), takeUntilDestroyed())
                .subscribe(event => this.onKeyDown(event));
            afterNextRender(() => {
                effect(() => {
                    const itemCmps = this.renderedItemCmps();
                    if (!itemCmps.length) {
                        return;
                    }
                    if (this.value === undefined || // If no value is set, select the first item
                        !itemCmps.some(item => item.nzValue() === this.value) // handle value not in options
                    ) {
                        this.service.selected$.next(itemCmps[0].nzValue());
                    }
                }, { injector: this.injector });
            });
        }
        ngOnChanges(changes) {
            const { nzName, nzOptions, nzDisabled } = changes;
            if (nzName) {
                this.service.setName(this.nzName);
            }
            if (nzOptions) {
                this.normalizedOptions = normalizeOptions(nzOptions.currentValue);
            }
            if (nzDisabled) {
                this.service.disabled$.next(nzDisabled.currentValue);
            }
        }
        handleThumbAnimationDone(event) {
            if (event.toState === 'to' || event.toState === 'toVertical') {
                this.animationState = null;
            }
            this.service.animationDone$.next(event);
        }
        onOffset(offset) {
            const items = this.renderedItemCmps();
            const total = items.length;
            const originIndex = items.findIndex(item => item.nzValue() === this.value);
            let nextIndex = (originIndex + offset + total) % total;
            // find out the next non-disabled item
            while (items[nextIndex].nzDisabled()) {
                nextIndex = (nextIndex + Math.sign(offset) + total) % total;
                // avoid circular loop
                if (nextIndex === originIndex) {
                    break;
                }
            }
            const nextOption = items[nextIndex];
            if (nextOption) {
                this.service.selected$.next(nextOption.nzValue());
                this.service.change$.next(nextOption.nzValue());
            }
        }
        // change selected item by direction keyboard interaction
        onKeyDown(event) {
            switch (event.keyCode) {
                case UP_ARROW:
                    this.onOffset(-1);
                    break;
                case LEFT_ARROW:
                    this.onOffset(this.dir() === 'rtl' ? 1 : -1);
                    break;
                case DOWN_ARROW:
                    this.onOffset(1);
                    break;
                case RIGHT_ARROW:
                    this.onOffset(this.dir() === 'rtl' ? -1 : 1);
                    break;
            }
        }
        writeValue(value) {
            this.service.selected$.next(value);
        }
        registerOnChange(fn) {
            this.onChange = fn;
        }
        registerOnTouched(fn) {
            this.onTouched = fn;
        }
        setDisabledState(disabled) {
            this.nzDisabled = (this.isDisabledFirstChange && this.nzDisabled) || disabled;
            this.isDisabledFirstChange = false;
        }
        static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
        static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.0", type: NzSegmentedComponent, isStandalone: true, selector: "nz-segmented", inputs: { nzBlock: ["nzBlock", "nzBlock", booleanAttribute], nzDisabled: ["nzDisabled", "nzDisabled", booleanAttribute], nzOptions: "nzOptions", nzVertical: ["nzVertical", "nzVertical", booleanAttribute], nzShape: "nzShape", nzSize: "nzSize", nzName: "nzName" }, outputs: { nzValueChange: "nzValueChange" }, host: { attributes: { "role": "radiogroup", "aria-label": "segmented control" }, properties: { "class.ant-segmented-disabled": "nzDisabled", "class.ant-segmented-rtl": "dir() === 'rtl'", "class.ant-segmented-lg": "nzSize === 'large'", "class.ant-segmented-sm": "nzSize === 'small'", "class.ant-segmented-block": "nzBlock", "class.ant-segmented-vertical": "nzVertical", "class.ant-segmented-shape-round": "nzShape === 'round'", "attr.tabindex": "nzDisabled ? undefined : 0" }, classAttribute: "ant-segmented" }, providers: [
                NzSegmentedService,
                {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(() => NzSegmentedComponent),
                    multi: true
                }
            ], queries: [{ propertyName: "contentItemCmps", predicate: NzSegmentedItemComponent, isSignal: true }], viewQueries: [{ propertyName: "viewItemCmps", predicate: NzSegmentedItemComponent, descendants: true, isSignal: true }], exportAs: ["nzSegmented"], usesOnChanges: true, ngImport: i0, template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      @if (animationState) {
        <div
          class="ant-segmented-thumb ant-segmented-thumb-motion"
          [@thumbMotion]="animationState"
          (@thumbMotion.done)="handleThumbAnimationDone($event)"
        ></div>
      }

      <ng-content>
        @for (item of normalizedOptions; track item.value) {
          <label nz-segmented-item [nzIcon]="item.icon" [nzValue]="item.value" [nzDisabled]="item.disabled">
            {{ item.label }}
          </label>
        }
      </ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: NzIconModule }, { kind: "ngmodule", type: NzOutletModule }, { kind: "component", type: NzSegmentedItemComponent, selector: "label[nz-segmented-item],label[nzSegmentedItem]", inputs: ["nzValue", "nzIcon", "nzDisabled"], exportAs: ["nzSegmentedItem"] }], animations: [thumbMotion], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
    };
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    selector: 'nz-segmented',
                    exportAs: 'nzSegmented',
                    template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      @if (animationState) {
        <div
          class="ant-segmented-thumb ant-segmented-thumb-motion"
          [@thumbMotion]="animationState"
          (@thumbMotion.done)="handleThumbAnimationDone($event)"
        ></div>
      }

      <ng-content>
        @for (item of normalizedOptions; track item.value) {
          <label nz-segmented-item [nzIcon]="item.icon" [nzValue]="item.value" [nzDisabled]="item.disabled">
            {{ item.label }}
          </label>
        }
      </ng-content>
    </div>
  `,
                    host: {
                        class: 'ant-segmented',
                        '[class.ant-segmented-disabled]': 'nzDisabled',
                        '[class.ant-segmented-rtl]': `dir() === 'rtl'`,
                        '[class.ant-segmented-lg]': `nzSize === 'large'`,
                        '[class.ant-segmented-sm]': `nzSize === 'small'`,
                        '[class.ant-segmented-block]': `nzBlock`,
                        '[class.ant-segmented-vertical]': `nzVertical`,
                        '[class.ant-segmented-shape-round]': `nzShape === 'round'`,
                        // a11y
                        role: 'radiogroup',
                        'aria-label': 'segmented control',
                        '[attr.tabindex]': 'nzDisabled ? undefined : 0'
                    },
                    providers: [
                        NzSegmentedService,
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NzSegmentedComponent),
                            multi: true
                        }
                    ],
                    animations: [thumbMotion],
                    imports: [NzIconModule, NzOutletModule, NzSegmentedItemComponent]
                }]
        }], ctorParameters: () => [], propDecorators: { nzBlock: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzDisabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzOptions: [{
                type: Input
            }], nzVertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzShape: [{
                type: Input
            }], nzSize: [{
                type: Input
            }], nzName: [{
                type: Input
            }], nzValueChange: [{
                type: Output
            }] } });
function thumbAnimationParamsOf(element, vertical = false) {
    if (vertical) {
        return {
            transform: element?.offsetTop ?? 0,
            width: element?.clientWidth ?? 0,
            height: element?.clientHeight ?? 0,
            vertical
        };
    }
    return {
        transform: element?.offsetLeft ?? 0,
        width: element?.clientWidth ?? 0
    };
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzSegmentedModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedModule, imports: [NzSegmentedComponent, NzSegmentedItemComponent], exports: [NzSegmentedComponent, NzSegmentedItemComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedModule, imports: [NzSegmentedComponent, NzSegmentedItemComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.0", ngImport: i0, type: NzSegmentedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [NzSegmentedComponent, NzSegmentedItemComponent],
                    exports: [NzSegmentedComponent, NzSegmentedItemComponent]
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NzSegmentedComponent, NzSegmentedItemComponent, NzSegmentedModule, normalizeOptions };
//# sourceMappingURL=ng-zorro-antd-segmented.mjs.map
